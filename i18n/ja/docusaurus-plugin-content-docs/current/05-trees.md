# 5. 木構造

この章では、一般的なデータ構造である木構造と関連アルゴリズムについて探求します。まず単純な木構造から概念を理解し、その後特殊な木構造である二分木について学びます。さらに、特殊な二分木である二分探索木についても探求します。加えて、平衡二分木についても学びます。

木構造は私たちの生活において非常に一般的な植物であり、以下の図のように表されます。

![木構造](/pics/trees.drawio.webp)

木構造には根があり、そこから複数の枝が分かれ、各枝には葉や他の小さな枝が付いています。実際、私たちの日常生活における多くのデータ構造は木構造のように見えます。例えば、家系図（ファミリーツリー）は一組の祖先から成長していきます。また、「枝分かれする」という表現でこのプロセスを説明することもあります。別の例としてファイル構造があり、フォルダにはいくつかのファイルや他のフォルダが含まれており、葉や枝のようになっています。数式も木構造として表現でき、各ノードは演算子、各葉は数値であり、根に近い演算子ほど後で計算されます。

## 木構造

データ構造において、木構造は階層的な関係を持つノードの有限集合です。各ノードはデータを格納する構造体です。この階層を家族関係（親、子、子孫、祖先など）で説明することが一般的です。隣接するノード間には親子関係があると言い、それらを親ノードと子ノードと呼びます。ノードの子孫とはそのノードから派生するすべてのノードであり、ノードの祖先とはそのノードが派生するすべてのノードです。

木構造が空でない場合、正確に1つの根ノードを持つ必要があります。根ノードは子ノードのみを持ち、親ノードを持ちません。根ノード以外のすべてのノードは正確に1つの親ノードを持つ必要があります。子ノードを持たないノード、つまりノードの最外層にあるノードは葉ノードと呼ばれ、木の葉に似ています。さらに、どのノードも自身の子孫になることはできません。つまり、木構造内に循環は存在できません。

![](/pics/abstract-tree-en.drawio.webp)

木構造において、辺とはノードの組$(u, v)$を指し、$u$が$v$の親ノードであるか、$v$が$u$の親ノードであるかのいずれかです。簡単に言えば、これら2つのノードには親子関係が必要です。図では親子関係を示すために矢印を使用し、矢印は祖先から子孫に向かって指します。

以下の例は木構造ではありません。

![](/pics/not-a-tree-en.drawio.webp)

各赤いマークは木構造の要件に違反しています。右上には親ノードを持たない別の根ノードがあり、木構造に2つの根ノードが存在することは許可されません。下部では、左の葉ノードが根ノードを指す余分な矢印を持っており、根ノードの親ノードであることを意味するため、構造要件に違反しています。また、右の葉ノードは2つの親ノードを持っており、これも要件に準拠していません。

根ノードを上部に配置し、子ノードを親ノードの下に配置するのが一般的です。木構造に関連するいくつかの用語があります。まず、ノードの深さは、根ノードからそのノードまでのパスの長さに対応します。言い換えると、根ノードから下に向かって移動する際に通過する辺の数です。したがって、根の深さは$0$です。次に、ノードの高さは、そのノードから葉ノードまでの最長パスの長さに対応します。同様に、葉ノードの高さは$0$です。最後に、木構造の高さは根ノードの高さと等しくなります。木構造にノードが1つしかない場合、それは根ノードでもあり葉ノードでもあり、高さは$0$です。木構造が空（ノードがない）場合、その高さを$-1$と定義します。ただし、書籍によっては異なる定義を採用し、木構造の層を考慮して根を第1層とする場合もあります。

これまで木の論理構造について議論してきましたが、次にその記憶構造について考えてみましょう。論理構造はデータ間の関係を定義するのに対し、記憶構造はデータの具体的な表現を定義します。ここでは、各ノードが最大2つの子を持つ二分木を例に取り、タプルのリストを使って木を表現します。各タプルは親子関係を定義しており、例えば `(0, 1)` はノード $0$ がノード $1$ の親であることを示します。

別の方法として、以前に説明した代数的データ構造を使用する方法もあります：

```moonbit no-check
Node(0,
  Node(1,
    Leaf(3),
    Empty),
  Leaf(2))
```

列挙型を使って複数のケースを定義します：`Node` は通常の木のノードを表し、自身の番号と2つの部分木を持ちます。`Leaf` は葉ノードのみからなる木を表し、自身の番号のみを持ちます。`Empty` は空の木を表します。この表現を使うと、先ほどと同様の木構造を定義できます。もちろん、これは可能な実装の一つに過ぎません。

最後の方法は、各レベルの構造が左から右へ連続的に配置されたリストです：

![](/pics/list-tree.drawio.webp)

例えば、ルートノードはリストの先頭に配置され、次に第2レベルのノードが左から右へ、さらに第3レベルのノードが左から右へ、というように続きます。したがって、ノード $3$ とその右側のノードはノード $1$ の子であり、その後の2つのノードはノード $2$ の子です。この例では、これら3つのノードはすべて空です。

これら3つの方法はすべて同じ木を定義していますが、記憶構造は大きく異なります。したがって、データの論理構造はその記憶構造から独立していると結論づけることができます。

最後に、木のデータ構造には多くの派生形があります。例えば、セグメント木は区間と対応するデータを格納するため、1次元のクエリに適しています。二分木は各ノードが最大2つの枝（左部分木と右部分木）を持つ特殊なタイプです。B木はシーケンシャルアクセスに適しており、ディスク上のデータ格納を容易にします。KD木とR木はそれぞれ二分木とB木の派生形で、空間データ構造の格納に適しています。これら以外にも多くの木構造が存在します。

## 二分木

二分木は空であるか、または最大2つの部分木（左部分木と右部分木）を持つノードで構成されます。例えば、葉ノードの両部分木は空です。ここでは、デフォルトのデータストレージとして整数を使用した再帰的列挙型に基づく定義を採用します。

```moonbit
enum IntTree {
  Node(Int, IntTree, IntTree) // data, left subtree, right subtree
  Empty
}
```

最初に説明するアルゴリズムは二分木の走査（または検索）です。木の走査とは、特定の順序で木のすべてのノードを重複なく訪問するプロセスを指します。通常、走査には2つの方法があります：深さ優先探索と幅優先探索です。深さ優先探索では、常に一方の部分木をもう一方よりも先に訪問します。部分木の走査中、その部分木の部分木を再帰的に訪問します。したがって、常に最も深いノードに最初に到達してから戻ります。例えば、

![](/pics/traversal-en.drawio.webp)

図では、最初に左部分木を訪問し、次に再び左部分木を訪問して $3$ に到達します。その後、右部分木を連続的に訪問し、$5$ に到達します。最後に、木全体の右部分木である $2$ を訪問します。一方、幅優先探索では、ルートノードから開始して層ごとに進み、特定の深さのノードをすべて訪問してからより深い層に進みます。同じ木の場合、幅優先探索では最初にルートノードを訪問し、次に部分木 $1$ と $2$、その後 $3$ と $4$、最後に最も深いノード $5$ を訪問します。

深さ優先探索には通常、先行順探索（preorder traversal）、中間順探索（inorder traversal）、後行順探索（postorder traversal）の3つのバリエーションがあります。違いは、木全体を探索する際に根ノードをいつ訪問するかです。例えば、先行順探索では、最初に根ノードを訪問し、次に左部分木、そして右部分木を訪問します。先ほどの木を例にとると、$0$から始まり、左部分木を訪問します。左部分木を訪問する際には、再び根ノードから始まり、これは$1$です。次に$3$、$4$、$5$、そして$2$と続きます。中間順探索では、最初に左部分木を訪問し、次に根ノード、そして右部分木を訪問します。したがって、最初に左部分木を訪問します。この時点でまだ左部分木があるため、木$3$まで下ります。これは葉ノードで左部分木がないため、根ノード$3$を訪問します。その後、部分木の根ノード$1$を訪問し、右部分木に進みます。後行順探索も同様のロジックで、最初に左部分木、次に右部分木、最後に根ノードを訪問します。実際、フィボナッチ数列を解くことは後行順探索と見なすことができます。なぜなら、最初に$(n-1)$番目と$(n-2)$番目の項（これらは2つの部分木）を訪問し、その後$n$番目の項（根ノードの値）を解くからです。幅優先探索については既に説明しました：左から右への順序は`[0, 1, 2, 3, 4, 5]`です。

木のノードから特定の値を探す際のこれら2つの探索の具体的な実装を見てみましょう。まず、深さ優先探索について考えます。

```moonbit
fn dfs_search(target: Int, tree: IntTree) -> Bool {
  match tree { // check the visited tree
    Empty => false // empty tree implies we are getting deepest
    Node(value, left, right) => // otherwise, search in subtrees
      value == target || dfs_search(target, left) || dfs_search(target, right)
  }
}
```

先に紹介したように、これは構造的再帰に基づく探索です。まず基本ケース、つまり木が空の場合（3行目に示す）を処理します。この場合、探している値が見つからなかったため、`false`を返します。次に、再帰ケースを処理します。ノードの場合、その値が目的の結果かどうかを確認します（5行目）。見つかった場合、結果は`true`です。それ以外の場合は、左部分木と右部分木を交互に探索し続けます。左部分木または右部分木のいずれかで見つかれば、結果は`true`になります。現在の二分木では、与えられた値を見つけるために左部分木と右部分木の両方を探索する必要があります。後で紹介する二分探索木はこのプロセスを最適化します。先行順、中間順、後行順探索の唯一の違いは、現在のノード、左部分木探索、右部分木探索の操作の順序です。

### キュー

次に、幅優先探索について続けます。

![](/pics/bfs-en.drawio.webp)

前述のように、幅優先探索は各部分木を層ごとに訪問します。この場合、訪問予定のすべての木を記録するために、新しいデータ構造であるキューが必要です。

![](/pics/queue-en.drawio.webp)

キューは先入れ先出し（FIFO）のデータ構造です。毎回、キューから木をデキューし、そのノード値が探している値かどうかを確認します。そうでない場合、空でない部分木を左から右にエンキューし、キューが空になるまで計算を続けます。

詳しく見てみましょう。現実世界の列と同じように、最初に列に入った人が最初にサービスを受けるため、到着順序を維持することが重要です。データの挿入と削除も同じ順序で行われます。図に示すように、$0$から$5$までの数字を順番に追加しました。$6$を追加すると、$5$の後に続きます。キューから削除する場合、最初に追加された$0$から始めます。

ここで使用しているキューは次のインターフェースで定義されています：

```moonbit no-check
fn empty[T]() -> Queue[T] // construct an empty queue
fn enqueue[T](q: Queue[T], x: T) -> Queue[T] // add element to the tail
// attempt to dequeue an element, return None if the queue is empty
fn pop[T](q: Queue[T]) -> (Option[T], Queue[T])
```

<!-- Implementation of Queue

```moonbit
struct Queue[T] {
  front:@immut/list.T[T]
  back:@immut/list.T[T]
}

/// `Queue::default[T]()`
///
/// Create an empty queue 创建空队列
fn Queue::default[T]() -> Queue[T] {
  { front: Nil, back: Nil }
}

fn empty[T]() -> Queue[T] {
  Queue::default()
}

/// `from_list[T](front: @immut/list.T[T])`
///
/// Create queue from a list 从列表创建队列
fn Queue::from_list[T](front: @immut/list.T[T]) -> Queue[T] {
  { front:front, back:Nil }
}

/// `is_empty[T](q: Queue[T])`
///
/// Check if a queue is empty 检查列表是否为空
fn Queue::is_empty[T](q: Queue[T]) -> Bool {
  match q {
    {front:Nil, back:Nil} => true
    _ => false
  }
}

/// `list_rev[T](xs: @immut/list.T[T])`
///
/// Reverse a list with tail recursion 基于尾递归的列表反转
fn list_rev[T](xs: @immut/list.T[T]) -> @immut/list.T[T] {
  fn go(acc, xs: @immut/list.T[T]) {
    match xs {
      Nil => acc
      Cons(x, rest) => go((Cons(x, acc) : @immut/list.T[T]), rest)
    }
  }

  go(Nil, xs)
}

/// `norm[T](q: Queue[T])`
///
/// Feed `back` into `front` so that `front` always have something 反转队列结构；确保列表头始终有元素
fn norm[T](q: Queue[T]) -> Queue[T] {
  match q {
    {front:Nil, back:b} => { front:list_rev(b), back:Nil }
    q => q
  }
}

/// `enqueue[T](q: Queue[T], x: T)`
///
/// Add an element to the end of the queue 向队尾添加一个元素
fn enqueue[T](q: Queue[T], x: T) -> Queue[T] {
  match q {
    {front:f, back:b} => norm({ front:f, back:Cons(x, b) })
  }
}

/// `pop[T](q: Queue[T])`
///
/// Remove the first element from the queue 取出队列中第一个元素
fn pop[T](q: Queue[T]) -> (Option[T], Queue[T]) {
  match q {
    {front:Nil, back:_} => (None, q)
    {front:Cons(x, f), back:b} => (Some(x), norm({front:f, back:b}))
  }
}
```
-->

`empty`: 空のキューを構築する; `enqueue`: 要素をキューに追加する、つまり末尾に追加する; `pop`: 要素をデキューしようと試み、残りのキューを返す。キューが既に空の場合、返される値は`None`と空のキューのペアとなる。例えば、

```moonbit no-check
let q = enqueue(enqueue(empty(), 1), 2)
let (head, tail) = pop(q)
assert(head == Some(1))
assert(tail == enqueue(empty(), 2))
```

空のキューに$1$と$2$を追加した。その後、要素をデキューしようとすると、`Some(1)`が得られ、残りは空のキューに$2$を追加したものと等価になる。

それでは、幅優先探索の実装に戻ろう。

```moonbit
fn bfs_search(target: Int, queue: Queue[IntTree]) -> Bool {
  match pop(queue) {
    (None, _) => false // If the queue is empty, end the search
    (Some(head), tail) => match head { // If the queue is not empty, operate on the extracted tree
      Empty => bfs_search(target, tail) // If the tree is empty, operate on the remaining queue
      Node(value, left, right) =>
        if value == target { true } else {
          // Otherwise, operate on the root node and add the subtrees to the queue
          bfs_search(target, enqueue(enqueue(tail, left), right))
        }
    }
  }
}
```

木のノードから特定の値を検索したい場合、パラメータで示されているように、木を含むキューを維持する必要がある。その後、現在のキューが空かどうかを確認する。キューの先頭に対して`pop`操作とパターンマッチングを行い、空であれば全ての検索を完了し値が見つからなかったため、`false`を返す。キューにまだ要素が残っている場合、この木に対して操作を行う。木が空であれば、残りのキューに対して直接操作を行う。木が空でない場合、以前と同様に、現在のノードが探している値かどうかを確認する。該当すれば`true`を返し、そうでなければ左右の部分木`left`と`right`をキューにエンキューして、キューの検索を続ける。

これで、木の走査に関する説明は一通り終了した。しかし、この種の検索はあまり効率的ではないように思えるかもしれない。なぜなら、全ての部分木に探している値が含まれている可能性があるからだ。検索回数を減らす方法はあるだろうか？その答えは、次に紹介する二分探索木にある。

## 二分探索木

先ほど、二分木での要素検索には木全体を走査する必要があるかもしれないと述べた。例えば、下図の木で要素$8$を探す場合を考えよう。

![](/pics/bst-en.drawio.webp)

左側の二分木では、木全体を検索する必要があり、最終的に$8$が木に含まれていないと結論づける。

検索を容易にするため、二分木のデータ配置に規則を設ける：左から右へ、データを昇順に並べる。これが二分探索木の誕生である。この規則によれば、左部分木の全てのデータはノードのデータより小さく、ノードのデータは右部分木のデータより小さくなければならない（右図参照）。

ここで、中間順走査を行うと、小さい順にソートされたデータを走査できることに気付く。二分探索木での検索は非常に単純だ：現在の値が探している値より小さいか、等しいか、大きいかを判断し、次に検索すべき部分木がわかる。上記の例で$8$が木に含まれるか確認する場合、$8$が$5$より大きいので、次は右部分木を検索する。$7$に到達すると、右部分木が存在しない、つまり$7$より大きい数値がないことがわかるため、$8$が木に含まれていないと結論づける。ご覧の通り、検索効率は大幅に向上した。実際、最悪の場合に必要な最大検索回数は木の高さプラス1であり、要素の総数ではない。場合によっては、木の高さが要素の総数と等しくなることもあるが、それについては後述する。

このような木を維持するには、挿入と削除のための特別なアルゴリズムが必要で、変更後の木も順序を維持できるようにする。これらの2つのアルゴリズムを探ってみよう。

![](/pics/bst-insertion.drawio.webp)

二分探索木への挿入についても、構造的再帰を使用します。まず、木が空である基底ケースを考えます。この場合、挿入したい値だけを含む新しいノードで木を置き換えます。次に、再帰的ケースを考えます。木が空でない場合、挿入したい値とノードの値を比較します。ノードの値より小さい場合は左部分木に挿入し、挿入後の部分木で左部分木を置き換えます。大きい場合は右部分木を置き換えます。例えば、3を挿入したい場合、各ノードと比較します。5より小さいので左部分木を操作し、その後2より大きいので右部分木を操作します。この部分木に注目すると、3は4より小さいので左部分木に挿入します。これが空の木なので、4だけを含む木で左部分木を置き換えます。

```moonbit
fn insert(tree: IntTree, value: Int) -> IntTree {
  match tree {
    Empty => Node(value, Empty, Empty) // construct a new tree if it's empty
    Node(v, left, right) => // if not empty, update one subtree by insertion
      if value == v { tree } else
      if value < v { Node(v, insert(left, value), right) } else
        { Node(v, left, insert(right, value)) }
  }
}
```

ここに完全な挿入コードを示します。3行目では元の木が空の場合に新しい木を再構築します。6行目と7行目では、部分木を更新する必要がある場合、更新された部分木に基づいて`Node`コンストラクタで新しい木を構築します。

次に、削除操作について説明します。

![](/pics/bst-deletion-en.drawio.webp)

同様に、構造的再帰で行います。木が空の場合は何もする必要がありません。木が空でない場合、現在の値と比較し、削除すべき値かどうかを判断します。削除する必要がある場合は削除します（削除方法は後述）。削除する値でない場合は、値が存在する可能性のある部分木を見つけ、削除後の更新された木を作成します。このプロセスで最も重要なのは、木の根ノードを削除する方法です。部分木がない場合や1つだけの場合は簡単で、空の木かその部分木で置き換えます。難しいのは部分木が2つある場合で、この場合は新しい根ノードとなる値を見つける必要があります。この値は左部分木の全ての値より大きく、右部分木の全ての値より小さい必要があります。この条件を満たす値は2つあります：左部分木の最大値と右部分木の最小値です。ここでは左部分木の最大値を使用します。図をもう一度見てみましょう。部分木がない場合は空の木で置き換え、1つの部分木がある場合はその部分木で置き換えます。2つの部分木がある場合は、左部分木の最大値を新しい根ノードの値に設定し、この値を左部分木から削除します。この値は最大でも1つの部分木しか持たないので、操作は比較的簡単です。

```moonbit
fn remove_largest(tree: IntTree) -> (IntTree, Int) {
    match tree {
    Node(v, left, Empty) => (left, v)
    Node(v, left, right) => {
        let (newRight, value) = remove_largest(right)
        (Node(v, left, newRight), value)
    } }
}
```

```moonbit no-check
fn remove(tree: IntTree, value: Int) -> IntTree {
    match tree { ...
      Node(root, left, right)  => if root == value {
        let (newLeft, newRoot) => remove_largest(left)
        Node(newRoot, newLeft, right)
    } else ... }
}
```

ここに二分探索木の削除の一部を示します。左部分木から最大値を見つけて削除するヘルパー関数を定義します。右部分木がなくなるまで右に進みます（右部分木がないことはそれより大きい値がないことを意味します）。これに基づいて削除を定義し、両部分木が空でない場合、このヘルパー関数を使って新しい左部分木と新しい根ノードを取得できます。具体的なコード実装は省略し、課後の練習問題とします。

### 平衡二分木

最後に、平衡二分木について詳しく説明します。二分探索木の説明で、二分探索木の最悪ケースの探索回数は木の高さに依存すると述べました。二分探索木への挿入と削除は木のバランスを崩す可能性があり、一方の部分木の高さが他方より大幅に大きくなる場合があります。例えば、1から5までの要素を順番に挿入すると、左下の図のような木が得られます。

![](/pics/worst-bst-en.drawio.webp)

この木全体において、左部分木の高さは空の木であるため$-1$であり、右部分木の高さは$3$です。この場合、最悪の探索回数は木の要素数である$5$回に等しくなります。しかし、木のバランスがより取れている場合、つまり2つの部分木の高さが近い場合、右図のようにノードの最大深度は最大でも$2$となり、これはおよそ$\log_2n$回（$n$は木の要素数）に相当します。対数関数の曲線を思い出せば、木の要素数が大きい場合、2つのシナリオ間で最悪探索時間に大きな差が生じ得ることがわかります。したがって、常に良好な検索性能を保証するため、この最悪ケースを回避したいと考えます。これを実現するために、任意のノードの左右部分木の高さがほぼ等しい「平衡二分木」と呼ばれるデータ構造を導入できます。代表的な平衡二分木にはAVL木、2-3木、赤黒木などがあります。ここでは比較的単純なAVL木について説明します。

二分平衡木でバランスを維持する鍵は、木が不平衡になった際に再配置によってバランスを回復できる点にあります。AVL木の挿入・削除操作は標準的な二分探索木と同様ですが、各操作後に調整を行い木の平衡性を保ちます。ノード定義には高さ属性を追加します。

```moonbit no-check
enum AVLTree {
  Empty
  // current value, left subtree, right subtree, height
  Node(Int, ~left: AVLTree, ~right: AVLTree, ~height: Int)
}
fn create(value : Int, ~left : AVLTree = Empty, ~right : AVLTree = Empty) -> AVLTree
fn height(tree: AVLTree) -> Int
```

ここでは[第3章](./functions-lists-recursion#labeled-argument-and-optional-arguments)と[第4章](./tuples-structs-enums#labeled-arguments)で紹介したラベル付き引数の構文を使用しています。`create`関数はデフォルトで両部分木が空の新しいAVL木を作成し、明示的に高さを管理しません。AVL木の挿入・削除操作は標準的な二分探索木と同様のため、詳細は割愛します。

![](/pics/rotation.drawio.webp)

要素の挿入または削除後、変更箇所から遡って最初の不平衡位置（$z$と呼ぶ）を発見します。次に$y$を$z$の高い方の部分木、$x$を$y$の高い方の部分木と表現します。再平衡化について議論します。第一のケースでは、$x$が$y$と$z$の間に位置します。この場合、$x$をその親と祖父母の上に移動できます。$x$の2つの部分木の深さが$1$減少し、木全体の高さが低減されます。$T_4$の深さは$1$増加しますが、元々左部分木より低かったため平衡性は保たれます。第二のケースでは、$x$が$y$と$z$と同じ側に位置します。この場合、$y$を根ノードにすることで木の高さを低減できます。目的は依然として、最も深い2つの部分木の深さを減らして左部分木の高さを下げることです。

```moonbit no-check
fn balance(left: AVLTree, z: Int, right: AVLTree) -> AVLTree {
  if height(left) > height(right) + 1 {
    match left {
      Node(y, left_l, left_r, _) =>
        if height(left_l) >= height(left_r) {
          create(left_l, y, create(lr, z, right)) // x is on y and z's same side
        } else { match left_r {
          Node(x, left_right_l, left_right_r, _) =>  // x is between y and z
            create(create(left_l, y, left_right_l), x, create(left_right_r, z, right))
        } }
    }
  } else { ... }
}
```

平衡木のコードスニペットを示します。前述の内容を理解すれば容易に完成できます。まず、2つの部分木の高さ差が特定値を超えているか、どちら側が高いかをチェックし、木が不平衡か判定します。判定後、再平衡操作を実行します。この時点で渡される根ノードは$z$であり、パターンマッチング後の高い側が$y$です。次に$y$の2つの部分木の高さを比較し、$x$が$y$と$z$と同じ側か間にあるかをさらに判定します（6行目）。その後、前述のシナリオに基づいて再構成します（6行目と9行目）。要素挿入を例にとると：

```moonbit no-check
fn add(tree: AVLTree, value: Int) -> AVLTree {
  match tree {
    // When encountering the pattern `Node(v, ..) as t`,
    // the compiler will know that `t` must be constructed by `Node`,
    // so `t.left` and `t.right` can be directly accessed within the branch.
    Node(v, ..) as t => {
      if value < v { balance(add(t.left, value), v, t.right) } else { ... }
    }
    Empty => ...
  }
}
```

要素挿入後、結果の木に対して直接再平衡操作を実行します。

## まとめ

この章では、木構造について紹介しました。具体的には、木の定義と関連用語、二分木の定義、走査アルゴリズム、二分探索木の定義とその挿入・削除操作、そして平衡二分木の一種であるAVL木のリバランス操作について説明しました。さらに学習を進めたい場合は、以下の文献を参照してください：

- _**アルゴリズムイントロダクション**_：第12章「二分探索木」
- _**アルゴリズムイントロダクション**_：第13章「赤黒木」