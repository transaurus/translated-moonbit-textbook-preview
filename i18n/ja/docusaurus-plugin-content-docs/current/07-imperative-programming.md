# 7. 命令型プログラミング

## 関数型プログラミング vs 命令型プログラミング

これまでの章では、同じ入力に対して常に同じ出力を返す関数型プログラミングのパラダイムを使用してきました。関数型プログラムは一般に参照透過性の性質を示します。つまり、プログラムの動作を変えることなく、関数呼び出しをその結果で置き換えることができます。

以下の例を考えてみましょう。変数`x`を宣言し、`1 + 1`のような式の結果を代入することができます。これは直感的で、数学で行うことと似ています。また、整数を受け取りその平方を返す関数`square`を定義することもできます。`square(x)`を呼び出すと、`{ 2 * 2 }`で置き換えた場合と同じく、結果として`4`が得られます。

```moonbit expr
let x: Int = 1 + 1 // x can be directly replaced with 2
fn square(x: Int) -> Int { x * x };
let z: Int = square(x) // can be replaced with { 2 * 2 }, still resulting in 4
```

しかし、現実の世界では、プログラムに計算以上のことを行わせる必要がしばしばあります。ファイルからの読み込み、画面への書き込み、メモリ内のデータ変更などです。これらの動作は「副作用」と呼ばれ、プログラムが同じ入力でも実行ごとに異なる動作をする可能性があります。これにより参照透過性が破壊され、プログラムの理解と予測が難しくなります。

この章では、命令型プログラミングの基本概念を学びます。これは、人間に指示を与えるようにコンピュータに実行すべき一連のコマンドを与えるプログラミングパラダイムです。数学的な関数を用いて求めたいものを定義する関数型プログラミングとは異なり、コンピュータに実行すべきことを正確に段階的に指示することに重点を置いています。

## コマンドと副作用

MoonBitで最もよく使われるコマンドの一つが`println`です。これは引数を画面に出力し、末尾に改行を追加します。「印刷」という動作は副作用であり、プログラム外の世界の状態を変更します。次に、副作用が[第2章](./development-environments-expressions)で確立した計算モデルにどのような課題を投げかけるかを見ていきます。

以下の例では、`x`に代入される値は式ブロックから得られます。このブロックではまず`println`コマンドが実行され、その後式`1 + 1`の結果が`x`に代入されます。最後に、`z`の値は`square(x)`の結果である`4`になります。この過程全体で、`println`は一度だけ実行されます。

```moonbit
fn square(x: Int) -> Int { x * x }
fn init {
  let x: Int = {
    println("hello moonbit") // Print once
    1 + 1 // 2
  }
  let z: Int = square(x) // 4
}
```

![](/pics/print_once.webp)

しかし、[第2章](./development-environments-expressions)で紹介した方法で`x`と`square`のすべての出現をその定義で置き換えると、次のプログラムが得られます：

```moonbit
fn init {
  let z: Int = {
    println("hello moonbit"); // Print once
    1 + 1 // 2
  } * {
    println("hello moonbit"); // Print twice
    1 + 1 // 2
  } // 4
}
```

![](/pics/print_twice.webp)

関数型プログラミングでは、2つのプログラムは同等であるべきです。なぜなら、同じ結果を計算するからです。しかし、`println`の副作用により、2つのプログラムの動作は異なります：前者は1行の出力を生成しますが、後者は2行の出力を生成します。このように、副作用は参照透過性を破壊し、プログラムの推論をより困難にすることがわかります。

### Unit型

[第2章](./development-environments-expressions#unit)では`Unit`型を紹介しましたが、当時はその使用法を明確に説明しませんでした。ここでは、命令型プログラミングにおいて`println`のようなコマンドが純粋に副作用のためであり、戻り値を持たないことがわかります。しかし、MoonBitではコマンドは特別な種類の式です。副作用を実行するだけでなく、ある値に還元できる必要があり、当然その値には特定の型が必要です。このような場合、`Unit`型を使用します。この型は唯一の値`()`で構成され、意味のある戻り値がないことを表すプレースホルダーとして適しています。

特に、MoonBitの`let`文は本質的にコマンドであり、その型も`Unit`です。例えば：

```moonbit
fn do_nothing() -> Unit {
  let _x = 0 // The `let` statement is of type `Unit`
}
```

## 可変変数

[第3章](./functions-lists-recursion)で学んだように、MoonBitでは`let mut`を使用して可変変数を作成でき、`<variable> = <expression>`というコマンドでバインディングを更新できます。このコマンドの型も`Unit`です。例：

```moonbit
fn init {
  let mut x = 1
  x = 10 // The assignment operation is a command.
}
```

[第4章](./tuples-structs-enums)では構造体について学びました。MoonBitでは、構造体のフィールドはデフォルトで不変ですが、可変フィールドもサポートされています。フィールドを可変にするには、`mut`でマークする必要があります。例：

```moonbit
struct Ref[T] { mut val : T }

fn init {
  let ref: Ref[Int] = { val: 1 } // `ref` itself is just a data binding
  ref.val = 10 // We can modify the fields of the struct
  println(ref.val.to_string()) // Output 10
}
```

可変データと不変データの区別は重要です。なぜなら、データの考え方に影響を与えるからです。以下の図に示すように、可変データの場合、識別子を値を保持する箱と考えることができます。

- 最初の図では、可変変数を変更する際、実質的に箱に格納された値を更新しています。
- 2番目の図では、`let`を使用して識別子`ref`を構造体にバインドしています。したがって、箱には構造体への参照が含まれます。`ref`を使用して構造体内の値を変更する場合、それが指す構造体に格納された値を更新しています。参照自体は変化しません。なぜなら、同じ構造体を指し続けるからです。
- 3番目の図では、可変な`ref`を定義して変更する場合、新しい箱を作成し、参照を新しい箱を指すように更新しています。

![](/pics/ref.drawio.webp)

### エイリアス

同じ可変データ構造を指す複数の識別子はエイリアスと見なされ、注意深く扱う必要があります。

次の例では、`alter`関数は`Ref`構造体への2つの可変参照`a`と`b`を取り、`a`の`val`フィールドを`10`に、`b`の`val`フィールドを`20`に変更します。`alter(x, x)`を呼び出すと、実質的に同じ可変参照`x`を2回渡すことになります。結果として、`x`の`val`フィールドは2回変更されます。なぜなら、`a`と`b`はどちらも同じ`x`参照を指すエイリアスだからです。

```moonbit
fn alter(a: Ref[Int], b: Ref[Int]) -> Unit {
  a.val = 10
  b.val = 20
}

fn init {
  let x: Ref[Int] = { val : 1 }
  alter(x, x)
  println(x.val.to_string()) // x.val will be changed twice
}
```

![](/pics/alias.drawio.webp)

## ループ

ループはコードブロックを複数回繰り返す方法です。MoonBitでは、`while`ループを使用してこれを行うことができます。まず、ループ変数（例えば`i`）を定義し、初期値を与えます。次に、`while`ループで定義された条件をチェックします。条件が真の場合、`while`ループの本体にあるコマンドを実行します。このプロセスは、条件が真でなくなるまで繰り返され、その時点でループは終了します。無限ループを避けるために、ループ本体内でループ変数を更新する必要があります。

```moonbit
fn init {
  let mut i = 0
  while i < 2 {
    println("Output")
    i += 1
  } // Repeat output 2 times
}
```

例えば、`0`から`1`までの数字を印刷したい場合があります。`i`が`2`未満かどうかをチェックするループでこれを行うことができます。真の場合、`i`の現在の値を印刷し、`i`を`1`増やし、プロセスを繰り返します。ループは`i`が`2`未満でなくなるまで続き、その後終了します。

### ループと再帰

ループと再帰は等価です。ループは特定の条件が満たされるまで繰り返す一連の命令であり、再帰は問題をより小さな類似の問題に分解して解決する方法です。プログラミングでは、ループを再帰関数として書き直したり、その逆を行ったりすることがよくあります。

例えば、フィボナッチ数列の計算を考えてみましょう。最後の2つの数字を追跡し、進むにつれて更新するループでこれを行うことができます。あるいは、基本ケース（0と1）に達するまで小さな数字で自身を呼び出す再帰関数を書くこともできます。

```moonbit
// Loop form
fn init {
  let mut i = 0
  while i < 2 {
    println("Hello!")
    i = i + 1
  }
}
```

```moonbit
// Recursive form
fn loop_(i: Int) -> Unit {
  if i < 2 {
    println("Hello!")
    loop_(i + 1)
  } else { () }
}
fn init {
  loop_(0)
}
```

### ループフローの制御

ループの流れをより精密に制御したい場合があります。現在のイテレーションの残りをスキップしたり、ループ全体を終了したりすることがあります。MoonBitでは、`break`を使用してループを早期に終了したり、`continue`を使用して現在のイテレーションの残りをスキップして次のイテレーションに進んだりできます。

例えば、0から9までの数字を出力する際に、数字3をスキップしたい場合は、ループ条件内で`continue`を使用できます。3に達した時点でループを完全に停止したい場合は、`break`を使用できます。

```moonbit
fn print_first_3_break() -> Unit {
  let mut i = 0
  while i < 10 {
    i += 1
    print(i)
    println(" yes")
    if i == 3 {
      break // Skip from 3 onwards
    } else {
      println(i.to_string())
    }
  }
}
```

期待される出力は

```text
1 yes
2 yes
```

しかし、`break`を`continue`に変更すると

```moonbit
fn print_first_3_continue() -> Unit {
  let mut i = 0
  while i < 10 {
    i += 1
    print(i)
    println(" yes")
    if i == 3 {
      continue // go into the next iteration
    } else {
      println(i.to_string())
    }
  }
}
```

期待される出力は

```text
1 yes
2 yes
 yes
 yes
 yes
 yes
 yes
 yes
 yes
```

## コードチェックとデバッグ

エラーを避けるためには、コードをチェックする必要があります。ただし、この作業はすべて自分で行う必要はなく、VS CodeのMoonBit拡張機能がある程度支援してくれます。以下にいくつかの例を示します：

- 可変変数が変更されていない場合、MoonBit拡張機能は警告を発し、ループカウンタの更新忘れなどのミスを捕捉するのに役立ちます。
  ![](/pics/infinite_loop.webp)
- また、関数の戻り値が宣言された戻り型と一致しているかどうかもチェックし、タイプミスを防ぐのに役立ちます。
  ![](/pics/forget_type.webp)

時には、コードが目視チェックやMoonBit拡張機能のチェックを通過しても、期待通りに動作しないことがあります。これはコードにバグがあることを意味します。そのような場合、コードをデバッグする必要があります。MoonBitのデバッガは、プログラムの実行中に内部で何が起こっているかを表示することで、コードのデバッグを支援するツールです。プログラムを任意の時点で一時停止し、変数の値を確認し、コードを1行ずつステップ実行できます。これは複雑な動作を理解し、バグを修正するのに非常に役立ちます。

![](/pics/debugger.webp)

## 可変データと不変データのトレードオフ

可変データは以前に確立した関数型計算モデルに挑戦し、いくつかの潜在的な問題を引き起こす可能性がありますが、さまざまなシナリオで広く使用されています。外部環境（例えばハードウェア）を直接操作したい場合、可変データ構造を使用する方が適しています。ランダムアクセスが必要な場合、可変配列は通常、不変リストよりも優れたパフォーマンスを発揮します。可変データはまた、グラフなどの複雑なデータ構造を構築するのを容易にします。さらに、可変データのインプレース変更は、追加のメモリ消費を導入しないため、メモリ空間をより効率的に利用できます。

可変データが常に参照透過性と衝突するわけではありません。次の例では、`while`ループといくつかの可変変数を使用して、フィボナッチ数列のn番目の項を計算しています。しかし、`fib_mut`の出現をその最終結果に安全に置き換えることができます。なぜなら、副作用を生じないからです。

```moonbit
fn fib_mut(n: Int) -> Int {
  let mut acc1 = 0; let mut acc2 = 1; let mut i = 0
  while i < n  {
    let t = acc1 + acc2
    acc1 = acc2;  acc2 = t
    i = i + 1
  }
  acc1
}
```

## まとめ

この章では、命令型プログラミングの基礎を探求しました。コンピュータに何をすべきかを指示するコマンドの使用、値を格納する変数、アクションを繰り返すループについて学びました。命令型プログラミングは関数型プログラミングとは本質的に異なり、両者のトレードオフを理解することが重要です。これらの概念を理解することで、適切なツールを選択し、効果的で理解しやすいプログラムを書くことができます。