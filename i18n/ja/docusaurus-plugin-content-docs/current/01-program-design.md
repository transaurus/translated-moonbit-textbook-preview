# 1. プログラム設計

## プログラム設計

プログラム設計とは、曖昧さを含む自然言語で記述された非公式な仕様をプログラムに変換するプロセスです。このアプローチには2つの視点があります：仕様を「満たす」プログラムを開発することと、仕様を「基に」プログラムを開発することです。ここで紹介するワークフローはテスト駆動開発（TDD）であり、仕様をテストケースに変換し、開発サイクルを通じてソフトウェアを反復的にテストすることで仕様との整合性を確保します。

### 基本的なワークフロー

TDDのワークフローは以下の4つのステップに分解できます：

- ステップ1: 問題を理解する

  このステップでは、関連する変数とそれらの関係性を把握することが重要です。

- ステップ2: インターフェースを定義する

  ここでは、プログラムが環境とどのように相互作用するかを定義します。これには他のプログラムとの関数インターフェースを通じた相互作用や、ユーザーとの入出力が含まれます。

- ステップ3: テストケースを作成する

  このステップでは、正常な入力と異常な入力に対する期待される動作を指定します。例えば、バーでビールを注文すればビールを受け取り、カクテルを注文すればビールではなくカクテルを受け取るべきです。しかし、もしチャーハンを注文したらどうなるでしょうか？

- ステップ4: プログラムを実装する

  大きな問題を扱う場合、それを小さなサブ問題に分解し、それぞれに対して上記のプロセスを繰り返す必要があるかもしれません。

### プログラム設計の例

この問題を見てみましょう（出典: [LeetCode 1518](https://leetcode.com/problems/water-bottles/description/)）：

> 最初に水が満たされた`num_bottles`本の水筒があります。市場では`num_exchange`本の空の水筒を1本の満タンの水筒と交換できます。
> 満タンの水筒を飲む操作は、それを空の水筒に変えます。
> 2つの整数`num_bottles`と`num_exchange`が与えられたとき、飲むことができる水筒の最大数を返してください。

#### ステップ1: 問題を理解する

この問題では、2つの変数が関与しています：

- $N_\mathrm{bottles}$: 現在所有している満タンの水筒の数
- $N_\mathrm{drunk}$: 飲んだ空の水筒の数

これらは以下のように関連しています：

- 最初、$N_\mathrm{bottles}$の値は入力で与えられます
- $N_\mathrm{bottles} \ge$ `num_exchange`の場合、そのうちの`num_exchange`本を飲み、1本の満タンの水筒と交換してこのプロセスを繰り返せます
- $N_\mathrm{bottles} <$ `num_exchange`の場合、それらを飲み尽くしてプロセスを終了しなければなりません

私たちの目標は、`num_bottles`と`num_exchange`が与えられたときに消費できる水筒の最大数を計算することです。

#### ステップ2: インターフェースを定義する

問題の説明によれば、入出力操作を処理する必要はありません。代わりに、2つの入力整数`num_bottles`と`num_exchange`に基づいて、水筒の最大数を表す整数を返す必要があります。したがって、インターフェースとして以下の関数を記述できます：

```moonbit expr
fn num_water_bottles(num_bottles: Int, num_exchange: Int) -> Int {
  abort("To be done")
}
```

この場合、MoonBitではプログラムの特定部分を未実装のままにしておいてもコンパイルが可能なため、インターフェースのみを定義しています。

#### ステップ3: テストケースを作成する

テストケースを作成するプロセスは、ソリューションを検証するだけでなく、問題への理解を深めるのにも役立ちます。このケースでは、2つのサンプルテストケースが提供されています：

```moonbit
test {
  assert_eq!(num_water_bottles(9, 3), 13) // 9 + 3 + 1 = 13
  assert_eq!(num_water_bottles(15, 4), 19)
}
```

最初のテストケースを例にとると、最初に$9$本の水のボトルがある場合、$9$本を消費した後、それらを交換して$3$本の追加ボトルを得ることができます。その後、それらの$3$本を消費すると、さらに$1$本を交換できます。しかし、その$1$本を消費した後はそれ以上交換できません。したがって、消費可能なボトルの総数は$9 + 3 + 1 = 13$本となります。

#### ステップ4: プログラムの実装

このステップでは、プログラムを実装し、テストケースを実行して検証することが可能です。ここでは、問題の分析を直接モデル化した可能な実装を示します。

```moonbit
fn num_water_bottles(num_bottles: Int, num_exchange: Int) -> Int {
  fn consume(num_bottles, num_drunk) {
    if num_bottles >= num_exchange {
      let num_bottles = num_bottles - num_exchange + 1
      let num_drunk = num_drunk + num_exchange
      consume(num_bottles, num_drunk)
    } else {
      num_bottles + num_drunk
    }
  }
  consume(num_bottles, 0)
}

test {
  assert_eq!(num_water_bottles(9, 3), 13) // 9 + 3 + 1 = 13
  assert_eq!(num_water_bottles(15, 4), 19)
}
```

プログラムは[こちら](https://try.moonbitlang.com/#79f7b666)で実行して検証できます。出力がない場合、プログラムが期待通りに動作したことを示します。あるいは、テストケースを変更してプログラムを再実行すると、エラーが観察されるかもしれません。

### まとめ

TDD（テスト駆動開発）のワークフローを採用することをお勧めします。具体的には、

1. 問題を理解する
2. インターフェースを定義する
3. テストケースを作成する
4. プログラムを実装する

現代のソフトウェア製品は通常大規模であるため、TDDはその開発において信頼性の高いワークフローです。事前にテストケースを作成することで、開発者は早期に潜在的なエラーを効率的に特定して修正できると同時に、新しい機能を既存の機能を中断することなくシームレスに統合できます。

クイズ: 水のボトル問題のサンプルプログラムは、いくつかの異常な入力に対して失敗する可能性があります。それらを特定できますか？（ヒント: MoonBitでは、`Int`値の範囲は$-2^{31}$から$2^{31} - 1$です。）